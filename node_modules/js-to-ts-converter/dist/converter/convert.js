"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts_morph_1 = require("ts-morph");
const add_class_property_declarations_1 = require("./add-class-property-declarations/add-class-property-declarations");
const add_optionals_to_function_params_1 = require("./add-optionals-to-function-params");
const filter_out_node_modules_1 = require("./filter-out-node-modules");
const logger_1 = require("../logger/logger");
/**
 * Converts the source .js code to .ts
 */
function convert(tsAstProject) {
    if (tsAstProject.getSourceFiles().length === 0) {
        logger_1.default.info('Found no source files to process. Exiting.');
        return tsAstProject;
    }
    // Print input files
    logger_1.default.info('Processing the following source files:');
    printSourceFilesList(tsAstProject, '  ');
    logger_1.default.info(`
		Converting source files... This may take anywhere from a few minutes to 
		tens of minutes or longer depending on how many files are being 
		converted.
	`.replace(/\t*/gm, ''));
    // Fill in PropertyDeclarations for properties used by ES6 classes
    logger_1.default.info('Adding property declarations to JS Classes...');
    tsAstProject = add_class_property_declarations_1.addClassPropertyDeclarations(tsAstProject);
    // Rename .js files to .ts files
    logger_1.default.info('Renaming .js files to .ts');
    tsAstProject.getSourceFiles().forEach(sourceFile => {
        const ext = sourceFile.getExtension();
        if (ext === '.js' || ext === '.jsx') {
            const dir = sourceFile.getDirectoryPath();
            const basename = sourceFile.getBaseNameWithoutExtension();
            const fileHasJsx = sourceFile.getFirstDescendantByKind(ts_morph_1.SyntaxKind.JsxElement); // in case there's a '.js' file which has JSX in it
            const extension = (fileHasJsx || ext === '.jsx') ? 'tsx' : 'ts';
            const outputFilePath = `${dir}/${basename}.${extension}`;
            logger_1.default.debug(`  Renaming ${sourceFile.getFilePath()} to ${outputFilePath}`);
            sourceFile.move(outputFilePath);
        }
    });
    // Filter out any node_modules files that accidentally got included by an import.
    // We don't want to modify these when we save the project
    tsAstProject = filter_out_node_modules_1.filterOutNodeModules(tsAstProject);
    // Make function parameters optional for calls that supply fewer arguments
    // than there are function parameters.
    // NOTE: Must happen after .js -> .ts rename for the TypeScript Language
    // Service to work.
    logger_1.default.info('Making parameters optional for calls that supply fewer args than function parameters...');
    tsAstProject = add_optionals_to_function_params_1.addOptionalsToFunctionParams(tsAstProject);
    // Filter out any node_modules files as we don't want to modify these when
    // we save the project. Also, some .d.ts files get included for some reason
    // like tslib.d.ts, so we don't want to output that as well.
    tsAstProject = filter_out_node_modules_1.filterOutNodeModules(tsAstProject);
    // Print output files
    logger_1.default.info('Outputting .ts files:');
    printSourceFilesList(tsAstProject, '  ');
    // Even though the `tsAstProject` has been mutated (it is not an immutable
    // data structure), return it anyway to avoid the confusion of an output
    // parameter.
    return tsAstProject;
}
exports.convert = convert;
/**
 * Private helper to print out the source files list in the given `astProject`
 * to the console.
 */
function printSourceFilesList(astProject, indent = '') {
    astProject.getSourceFiles().forEach(sf => {
        logger_1.default.info(`${indent}${sf.getFilePath()}`);
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb252ZXJ0ZXIvY29udmVydC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHVDQUErQztBQUMvQyx1SEFBaUg7QUFDakgseUZBQWtGO0FBQ2xGLHVFQUFpRTtBQUNqRSw2Q0FBc0M7QUFFdEM7O0dBRUc7QUFDSCxpQkFBeUIsWUFBcUI7SUFDN0MsSUFBSSxZQUFZLENBQUMsY0FBYyxFQUFFLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRztRQUNoRCxnQkFBTSxDQUFDLElBQUksQ0FBRSw0Q0FBNEMsQ0FBRSxDQUFDO1FBQzVELE9BQU8sWUFBWSxDQUFDO0tBQ3BCO0lBRUQsb0JBQW9CO0lBQ3BCLGdCQUFNLENBQUMsSUFBSSxDQUFFLHdDQUF3QyxDQUFFLENBQUM7SUFDeEQsb0JBQW9CLENBQUUsWUFBWSxFQUFFLElBQUksQ0FBRSxDQUFDO0lBRTNDLGdCQUFNLENBQUMsSUFBSSxDQUFFOzs7O0VBSVosQ0FBQyxPQUFPLENBQUUsT0FBTyxFQUFFLEVBQUUsQ0FBRSxDQUFFLENBQUM7SUFFM0Isa0VBQWtFO0lBQ2xFLGdCQUFNLENBQUMsSUFBSSxDQUFFLCtDQUErQyxDQUFFLENBQUM7SUFDL0QsWUFBWSxHQUFHLDhEQUE0QixDQUFFLFlBQVksQ0FBRSxDQUFDO0lBRTVELGdDQUFnQztJQUNoQyxnQkFBTSxDQUFDLElBQUksQ0FBRSwyQkFBMkIsQ0FBRSxDQUFDO0lBQzNDLFlBQVksQ0FBQyxjQUFjLEVBQUUsQ0FBQyxPQUFPLENBQUUsVUFBVSxDQUFDLEVBQUU7UUFDbkQsTUFBTSxHQUFHLEdBQUcsVUFBVSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBRXRDLElBQUksR0FBRyxLQUFLLEtBQUssSUFBSSxHQUFHLEtBQUssTUFBTSxFQUFHO1lBQ3JDLE1BQU0sR0FBRyxHQUFHLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQzFDLE1BQU0sUUFBUSxHQUFHLFVBQVUsQ0FBQywyQkFBMkIsRUFBRSxDQUFDO1lBQzFELE1BQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBRSxxQkFBVSxDQUFDLFVBQVUsQ0FBRSxDQUFDLENBQUUsbURBQW1EO1lBQ3JJLE1BQU0sU0FBUyxHQUFHLENBQUUsVUFBVSxJQUFJLEdBQUcsS0FBSyxNQUFNLENBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDbEUsTUFBTSxjQUFjLEdBQUcsR0FBRyxHQUFHLElBQUksUUFBUSxJQUFJLFNBQVMsRUFBRSxDQUFDO1lBRXpELGdCQUFNLENBQUMsS0FBSyxDQUFFLGNBQWMsVUFBVSxDQUFDLFdBQVcsRUFBRSxPQUFPLGNBQWMsRUFBRSxDQUFFLENBQUM7WUFDOUUsVUFBVSxDQUFDLElBQUksQ0FBRSxjQUFjLENBQUUsQ0FBQztTQUNsQztJQUNGLENBQUMsQ0FBRSxDQUFDO0lBRUosaUZBQWlGO0lBQ2pGLHlEQUF5RDtJQUN6RCxZQUFZLEdBQUcsOENBQW9CLENBQUUsWUFBWSxDQUFFLENBQUM7SUFFcEQsMEVBQTBFO0lBQzFFLHNDQUFzQztJQUN0Qyx3RUFBd0U7SUFDeEUsbUJBQW1CO0lBQ25CLGdCQUFNLENBQUMsSUFBSSxDQUFFLHlGQUF5RixDQUFFLENBQUM7SUFDekcsWUFBWSxHQUFHLCtEQUE0QixDQUFFLFlBQVksQ0FBRSxDQUFDO0lBRTVELDBFQUEwRTtJQUMxRSwyRUFBMkU7SUFDM0UsNERBQTREO0lBQzVELFlBQVksR0FBRyw4Q0FBb0IsQ0FBRSxZQUFZLENBQUUsQ0FBQztJQUVwRCxxQkFBcUI7SUFDckIsZ0JBQU0sQ0FBQyxJQUFJLENBQUUsdUJBQXVCLENBQUUsQ0FBQztJQUN2QyxvQkFBb0IsQ0FBRSxZQUFZLEVBQUUsSUFBSSxDQUFFLENBQUM7SUFFM0MsMEVBQTBFO0lBQzFFLHdFQUF3RTtJQUN4RSxhQUFhO0lBQ2IsT0FBTyxZQUFZLENBQUM7QUFDckIsQ0FBQztBQTdERCwwQkE2REM7QUFHRDs7O0dBR0c7QUFDSCw4QkFBK0IsVUFBbUIsRUFBRSxNQUFNLEdBQUcsRUFBRTtJQUM5RCxVQUFVLENBQUMsY0FBYyxFQUFFLENBQUMsT0FBTyxDQUFFLEVBQUUsQ0FBQyxFQUFFO1FBQ3pDLGdCQUFNLENBQUMsSUFBSSxDQUFFLEdBQUcsTUFBTSxHQUFHLEVBQUUsQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFFLENBQUM7SUFDL0MsQ0FBQyxDQUFFLENBQUM7QUFDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJvamVjdCwgU3ludGF4S2luZCB9IGZyb20gXCJ0cy1tb3JwaFwiO1xuaW1wb3J0IHsgYWRkQ2xhc3NQcm9wZXJ0eURlY2xhcmF0aW9ucyB9IGZyb20gXCIuL2FkZC1jbGFzcy1wcm9wZXJ0eS1kZWNsYXJhdGlvbnMvYWRkLWNsYXNzLXByb3BlcnR5LWRlY2xhcmF0aW9uc1wiO1xuaW1wb3J0IHsgYWRkT3B0aW9uYWxzVG9GdW5jdGlvblBhcmFtcyB9IGZyb20gXCIuL2FkZC1vcHRpb25hbHMtdG8tZnVuY3Rpb24tcGFyYW1zXCI7XG5pbXBvcnQgeyBmaWx0ZXJPdXROb2RlTW9kdWxlcyB9IGZyb20gXCIuL2ZpbHRlci1vdXQtbm9kZS1tb2R1bGVzXCI7XG5pbXBvcnQgbG9nZ2VyIGZyb20gXCIuLi9sb2dnZXIvbG9nZ2VyXCI7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHNvdXJjZSAuanMgY29kZSB0byAudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnQoIHRzQXN0UHJvamVjdDogUHJvamVjdCApOiBQcm9qZWN0IHtcblx0aWYoIHRzQXN0UHJvamVjdC5nZXRTb3VyY2VGaWxlcygpLmxlbmd0aCA9PT0gMCApIHtcblx0XHRsb2dnZXIuaW5mbyggJ0ZvdW5kIG5vIHNvdXJjZSBmaWxlcyB0byBwcm9jZXNzLiBFeGl0aW5nLicgKTtcblx0XHRyZXR1cm4gdHNBc3RQcm9qZWN0O1xuXHR9XG5cblx0Ly8gUHJpbnQgaW5wdXQgZmlsZXNcblx0bG9nZ2VyLmluZm8oICdQcm9jZXNzaW5nIHRoZSBmb2xsb3dpbmcgc291cmNlIGZpbGVzOicgKTtcblx0cHJpbnRTb3VyY2VGaWxlc0xpc3QoIHRzQXN0UHJvamVjdCwgJyAgJyApO1xuXG5cdGxvZ2dlci5pbmZvKCBgXG5cdFx0Q29udmVydGluZyBzb3VyY2UgZmlsZXMuLi4gVGhpcyBtYXkgdGFrZSBhbnl3aGVyZSBmcm9tIGEgZmV3IG1pbnV0ZXMgdG8gXG5cdFx0dGVucyBvZiBtaW51dGVzIG9yIGxvbmdlciBkZXBlbmRpbmcgb24gaG93IG1hbnkgZmlsZXMgYXJlIGJlaW5nIFxuXHRcdGNvbnZlcnRlZC5cblx0YC5yZXBsYWNlKCAvXFx0Ki9nbSwgJycgKSApO1xuXG5cdC8vIEZpbGwgaW4gUHJvcGVydHlEZWNsYXJhdGlvbnMgZm9yIHByb3BlcnRpZXMgdXNlZCBieSBFUzYgY2xhc3Nlc1xuXHRsb2dnZXIuaW5mbyggJ0FkZGluZyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgdG8gSlMgQ2xhc3Nlcy4uLicgKTtcblx0dHNBc3RQcm9qZWN0ID0gYWRkQ2xhc3NQcm9wZXJ0eURlY2xhcmF0aW9ucyggdHNBc3RQcm9qZWN0ICk7XG5cblx0Ly8gUmVuYW1lIC5qcyBmaWxlcyB0byAudHMgZmlsZXNcblx0bG9nZ2VyLmluZm8oICdSZW5hbWluZyAuanMgZmlsZXMgdG8gLnRzJyApO1xuXHR0c0FzdFByb2plY3QuZ2V0U291cmNlRmlsZXMoKS5mb3JFYWNoKCBzb3VyY2VGaWxlID0+IHtcblx0XHRjb25zdCBleHQgPSBzb3VyY2VGaWxlLmdldEV4dGVuc2lvbigpO1xuXG5cdFx0aWYoIGV4dCA9PT0gJy5qcycgfHwgZXh0ID09PSAnLmpzeCcgKSB7XG5cdFx0XHRjb25zdCBkaXIgPSBzb3VyY2VGaWxlLmdldERpcmVjdG9yeVBhdGgoKTtcblx0XHRcdGNvbnN0IGJhc2VuYW1lID0gc291cmNlRmlsZS5nZXRCYXNlTmFtZVdpdGhvdXRFeHRlbnNpb24oKTtcblx0XHRcdGNvbnN0IGZpbGVIYXNKc3ggPSBzb3VyY2VGaWxlLmdldEZpcnN0RGVzY2VuZGFudEJ5S2luZCggU3ludGF4S2luZC5Kc3hFbGVtZW50ICk7ICAvLyBpbiBjYXNlIHRoZXJlJ3MgYSAnLmpzJyBmaWxlIHdoaWNoIGhhcyBKU1ggaW4gaXRcblx0XHRcdGNvbnN0IGV4dGVuc2lvbiA9ICggZmlsZUhhc0pzeCB8fCBleHQgPT09ICcuanN4JyApID8gJ3RzeCcgOiAndHMnO1xuXHRcdFx0Y29uc3Qgb3V0cHV0RmlsZVBhdGggPSBgJHtkaXJ9LyR7YmFzZW5hbWV9LiR7ZXh0ZW5zaW9ufWA7XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZyggYCAgUmVuYW1pbmcgJHtzb3VyY2VGaWxlLmdldEZpbGVQYXRoKCl9IHRvICR7b3V0cHV0RmlsZVBhdGh9YCApO1xuXHRcdFx0c291cmNlRmlsZS5tb3ZlKCBvdXRwdXRGaWxlUGF0aCApO1xuXHRcdH1cblx0fSApO1xuXG5cdC8vIEZpbHRlciBvdXQgYW55IG5vZGVfbW9kdWxlcyBmaWxlcyB0aGF0IGFjY2lkZW50YWxseSBnb3QgaW5jbHVkZWQgYnkgYW4gaW1wb3J0LlxuXHQvLyBXZSBkb24ndCB3YW50IHRvIG1vZGlmeSB0aGVzZSB3aGVuIHdlIHNhdmUgdGhlIHByb2plY3Rcblx0dHNBc3RQcm9qZWN0ID0gZmlsdGVyT3V0Tm9kZU1vZHVsZXMoIHRzQXN0UHJvamVjdCApO1xuXG5cdC8vIE1ha2UgZnVuY3Rpb24gcGFyYW1ldGVycyBvcHRpb25hbCBmb3IgY2FsbHMgdGhhdCBzdXBwbHkgZmV3ZXIgYXJndW1lbnRzXG5cdC8vIHRoYW4gdGhlcmUgYXJlIGZ1bmN0aW9uIHBhcmFtZXRlcnMuXG5cdC8vIE5PVEU6IE11c3QgaGFwcGVuIGFmdGVyIC5qcyAtPiAudHMgcmVuYW1lIGZvciB0aGUgVHlwZVNjcmlwdCBMYW5ndWFnZVxuXHQvLyBTZXJ2aWNlIHRvIHdvcmsuXG5cdGxvZ2dlci5pbmZvKCAnTWFraW5nIHBhcmFtZXRlcnMgb3B0aW9uYWwgZm9yIGNhbGxzIHRoYXQgc3VwcGx5IGZld2VyIGFyZ3MgdGhhbiBmdW5jdGlvbiBwYXJhbWV0ZXJzLi4uJyApO1xuXHR0c0FzdFByb2plY3QgPSBhZGRPcHRpb25hbHNUb0Z1bmN0aW9uUGFyYW1zKCB0c0FzdFByb2plY3QgKTtcblxuXHQvLyBGaWx0ZXIgb3V0IGFueSBub2RlX21vZHVsZXMgZmlsZXMgYXMgd2UgZG9uJ3Qgd2FudCB0byBtb2RpZnkgdGhlc2Ugd2hlblxuXHQvLyB3ZSBzYXZlIHRoZSBwcm9qZWN0LiBBbHNvLCBzb21lIC5kLnRzIGZpbGVzIGdldCBpbmNsdWRlZCBmb3Igc29tZSByZWFzb25cblx0Ly8gbGlrZSB0c2xpYi5kLnRzLCBzbyB3ZSBkb24ndCB3YW50IHRvIG91dHB1dCB0aGF0IGFzIHdlbGwuXG5cdHRzQXN0UHJvamVjdCA9IGZpbHRlck91dE5vZGVNb2R1bGVzKCB0c0FzdFByb2plY3QgKTtcblxuXHQvLyBQcmludCBvdXRwdXQgZmlsZXNcblx0bG9nZ2VyLmluZm8oICdPdXRwdXR0aW5nIC50cyBmaWxlczonICk7XG5cdHByaW50U291cmNlRmlsZXNMaXN0KCB0c0FzdFByb2plY3QsICcgICcgKTtcblxuXHQvLyBFdmVuIHRob3VnaCB0aGUgYHRzQXN0UHJvamVjdGAgaGFzIGJlZW4gbXV0YXRlZCAoaXQgaXMgbm90IGFuIGltbXV0YWJsZVxuXHQvLyBkYXRhIHN0cnVjdHVyZSksIHJldHVybiBpdCBhbnl3YXkgdG8gYXZvaWQgdGhlIGNvbmZ1c2lvbiBvZiBhbiBvdXRwdXRcblx0Ly8gcGFyYW1ldGVyLlxuXHRyZXR1cm4gdHNBc3RQcm9qZWN0O1xufVxuXG5cbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgdG8gcHJpbnQgb3V0IHRoZSBzb3VyY2UgZmlsZXMgbGlzdCBpbiB0aGUgZ2l2ZW4gYGFzdFByb2plY3RgXG4gKiB0byB0aGUgY29uc29sZS5cbiAqL1xuZnVuY3Rpb24gcHJpbnRTb3VyY2VGaWxlc0xpc3QoIGFzdFByb2plY3Q6IFByb2plY3QsIGluZGVudCA9ICcnICkge1xuXHRhc3RQcm9qZWN0LmdldFNvdXJjZUZpbGVzKCkuZm9yRWFjaCggc2YgPT4ge1xuXHRcdGxvZ2dlci5pbmZvKCBgJHtpbmRlbnR9JHtzZi5nZXRGaWxlUGF0aCgpfWAgKTtcblx0fSApO1xufSJdfQ==