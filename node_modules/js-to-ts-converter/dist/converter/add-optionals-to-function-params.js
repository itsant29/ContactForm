"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts_morph_1 = require("ts-morph");
const logger_1 = require("../logger/logger");
/**
 * Adds the question token to function/method/constructor parameters that are
 * deemed to be optional based on the calls to that function/method/constructor
 * in the codebase.
 *
 * For example, if we have:
 *
 *     function myFn( arg1, arg2, arg3 ) {
 *         // ...
 *     }
 *
 *     myFn( 1, 2, 3 );  // all 3 args provided
 *     myFn( 1, 2 );     // <-- a call site only provides two arguments
 *
 * Then the resulting TypeScript function will be:
 *
 *     function myFn( arg1, arg2, arg3? ) {   // <-- arg3 marked as optional
 *         // ...
 *     }
 *
 * Note: Just calling the language service to look up references takes a lot of
 * time. Might have to optimize this somehow in the future.
 */
function addOptionalsToFunctionParams(tsAstProject) {
    logger_1.default.verbose('Beginning routine to mark function parameters as optional when calls exist that supply fewer args than parameters...');
    const sourceFiles = tsAstProject.getSourceFiles();
    logger_1.default.verbose('Parsing function/method/constructor calls from codebase.');
    const constructorMinArgsMap = parseClassConstructorCalls(sourceFiles);
    const functionsMinArgsMap = parseFunctionAndMethodCalls(sourceFiles);
    logger_1.default.verbose('Marking parameters as optional');
    addOptionals(constructorMinArgsMap);
    addOptionals(functionsMinArgsMap);
    return tsAstProject;
}
exports.addOptionalsToFunctionParams = addOptionalsToFunctionParams;
/**
 * Finds the call sites of each ClassDeclaration's constructor in order to
 * determine if any of its parameters should be marked as optional.
 *
 * Returns a Map keyed by ClassDeclaration which contains the minimum number of
 * arguments passed to that class's constructor.
 *
 * Actually marking the parameters as optional is done in a separate phase.
 */
function parseClassConstructorCalls(sourceFiles) {
    logger_1.default.verbose('Finding all calls to class constructors...');
    const constructorMinArgsMap = new Map();
    sourceFiles.forEach((sourceFile) => {
        logger_1.default.verbose(`  Processing classes in source file: ${sourceFile.getFilePath()}`);
        const classes = sourceFile.getDescendantsOfKind(ts_morph_1.SyntaxKind.ClassDeclaration);
        classes.forEach((classDeclaration) => {
            const constructorFns = classDeclaration.getConstructors() || [];
            const constructorFn = constructorFns.length > 0 ? constructorFns[0] : undefined; // only grab the first since we're converting JavaScript
            // If there is no constructor function for this class, then nothing to do
            if (!constructorFn) {
                return;
            }
            logger_1.default.verbose(`    Looking for calls to the constructor of class: '${classDeclaration.getName()}'`);
            const constructorFnParams = constructorFn.getParameters();
            const numParams = constructorFnParams.length;
            const referencedNodes = classDeclaration.findReferencesAsNodes();
            const callsToConstructor = referencedNodes
                .map((node) => node.getFirstAncestorByKind(ts_morph_1.SyntaxKind.NewExpression))
                .filter((node) => !!node);
            logger_1.default.debug(`    Found ${callsToConstructor.length} call(s) to the constructor`);
            const minNumberOfCallArgs = callsToConstructor
                .reduce((minCallArgs, call) => {
                return Math.min(minCallArgs, call.getArguments().length);
            }, numParams);
            if (callsToConstructor.length > 0) {
                logger_1.default.debug(`    Constructor currently expects ${numParams} params. Call(s) to the constructor supply a minimum of ${minNumberOfCallArgs} args.`);
            }
            constructorMinArgsMap.set(constructorFn, minNumberOfCallArgs);
        });
    });
    return constructorMinArgsMap;
}
/**
 * Finds the call sites of each FunctionDeclaration or MethodDeclaration in
 * order to determine if any of its parameters should be marked as optional.
 *
 * Returns a Map keyed by FunctionDeclaration or MethodDeclaration which contains
 * the minimum number of arguments passed to that function/method.
 *
 * Actually marking the parameters as optional is done in a separate phase.
 */
function parseFunctionAndMethodCalls(sourceFiles) {
    logger_1.default.verbose('Finding all calls to functions/methods...');
    const functionsMinArgsMap = new Map();
    sourceFiles.forEach((sourceFile) => {
        logger_1.default.verbose(`  Processing functions/methods in source file: ${sourceFile.getFilePath()}`);
        const fns = getFunctionsAndMethods(sourceFile);
        fns.forEach((fn) => {
            logger_1.default.verbose(`    Looking for calls to the function: '${fn.getName()}'`);
            const fnParams = fn.getParameters();
            const numParams = fnParams.length;
            const referencedNodes = fn.findReferencesAsNodes();
            const callsToFunction = referencedNodes
                .map((node) => node.getFirstAncestorByKind(ts_morph_1.SyntaxKind.CallExpression))
                .filter((node) => !!node);
            logger_1.default.debug(`    Found ${callsToFunction.length} call(s) to the function '${fn.getName()}'`);
            const minNumberOfCallArgs = callsToFunction
                .reduce((minCallArgs, call) => {
                return Math.min(minCallArgs, call.getArguments().length);
            }, numParams);
            if (callsToFunction.length > 0) {
                logger_1.default.debug(`    Function currently expects ${numParams} params. Call(s) to the function/method supply a minimum of ${minNumberOfCallArgs} args.`);
            }
            functionsMinArgsMap.set(fn, minNumberOfCallArgs);
        });
    });
    return functionsMinArgsMap;
}
/**
 * Retrieves all FunctionDeclarations and MethodDeclarations from the given
 * source file.
 */
function getFunctionsAndMethods(sourceFile) {
    return [].concat(sourceFile.getDescendantsOfKind(ts_morph_1.SyntaxKind.FunctionDeclaration), sourceFile.getDescendantsOfKind(ts_morph_1.SyntaxKind.MethodDeclaration));
}
/**
 * Marks parameters of class constructors / methods / functions as optional
 * based on the minimum number of arguments passed in at its call sites.
 *
 * Ex:
 *
 *     class SomeClass {
 *         constructor( arg1, arg2 ) {}
 *     }
 *     new SomeClass( 1 );  // no arg2
 *
 *     function myFn( arg1, arg2 ) {}
 *     myFn();  // no args
 *
 *
 * Output class and function:
 *
 *     class SomeClass {
 *         constructor( arg1, arg2? ) {}  // <-- arg2 marked as optional
 *     }
 *
 *     function myFn( arg1?, arg2? ) {}   // <-- arg1 and arg2 marked as optional
 */
function addOptionals(minArgsMap) {
    const fns = minArgsMap.keys();
    for (const fn of fns) {
        const fnParams = fn.getParameters();
        const numParams = fnParams.length;
        const minNumberOfCallArgs = minArgsMap.get(fn);
        // Mark all parameters greater than the minNumberOfCallArgs as
        // optional (if it's not a rest parameter or already has a default value)
        for (let i = minNumberOfCallArgs; i < numParams; i++) {
            const param = fnParams[i];
            if (!param.isRestParameter() && !param.hasInitializer()) {
                param.setHasQuestionToken(true);
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRkLW9wdGlvbmFscy10by1mdW5jdGlvbi1wYXJhbXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvY29udmVydGVyL2FkZC1vcHRpb25hbHMtdG8tZnVuY3Rpb24tcGFyYW1zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsdUNBQWtMO0FBQ2xMLDZDQUFzQztBQUt0Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCRztBQUNILHNDQUE4QyxZQUFxQjtJQUNsRSxnQkFBTSxDQUFDLE9BQU8sQ0FBRSxzSEFBc0gsQ0FBRSxDQUFDO0lBQ3pJLE1BQU0sV0FBVyxHQUFHLFlBQVksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUVsRCxnQkFBTSxDQUFDLE9BQU8sQ0FBRSwwREFBMEQsQ0FBRSxDQUFDO0lBQzdFLE1BQU0scUJBQXFCLEdBQUcsMEJBQTBCLENBQUUsV0FBVyxDQUFFLENBQUM7SUFDeEUsTUFBTSxtQkFBbUIsR0FBRywyQkFBMkIsQ0FBRSxXQUFXLENBQUUsQ0FBQztJQUV2RSxnQkFBTSxDQUFDLE9BQU8sQ0FBRSxnQ0FBZ0MsQ0FBRSxDQUFDO0lBQ25ELFlBQVksQ0FBRSxxQkFBcUIsQ0FBRSxDQUFDO0lBQ3RDLFlBQVksQ0FBRSxtQkFBbUIsQ0FBRSxDQUFDO0lBRXBDLE9BQU8sWUFBWSxDQUFDO0FBQ3JCLENBQUM7QUFiRCxvRUFhQztBQUdEOzs7Ozs7OztHQVFHO0FBQ0gsb0NBQXFDLFdBQXlCO0lBQzdELGdCQUFNLENBQUMsT0FBTyxDQUFFLDRDQUE0QyxDQUFFLENBQUM7SUFDL0QsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLEdBQUcsRUFBa0MsQ0FBQztJQUV4RSxXQUFXLENBQUMsT0FBTyxDQUFFLENBQUUsVUFBc0IsRUFBRyxFQUFFO1FBQ2pELGdCQUFNLENBQUMsT0FBTyxDQUFFLHdDQUF3QyxVQUFVLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBRSxDQUFDO1FBQ3JGLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FB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dEUsTUFBTSxHQUFHLEdBQUcsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDO0lBRTlCLEtBQUssTUFBTSxFQUFFLElBQUksR0FBRyxFQUFHO1FBQ3RCLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUVwQyxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDO1FBQ2xDLE1BQU0sbUJBQW1CLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBRSxFQUFFLENBQUcsQ0FBQztRQUVsRCw4REFBOEQ7UUFDOUQseUVBQXlFO1FBQ3pFLEtBQUssSUFBSSxDQUFDLEdBQUcsbUJBQW1CLEVBQUUsQ0FBQyxHQUFHLFNBQVMsRUFBRSxDQUFDLEVBQUUsRUFBRztZQUN0RCxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUUsQ0FBQyxDQUFFLENBQUM7WUFFNUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsRUFBRztnQkFDekQsS0FBSyxDQUFDLG1CQUFtQixDQUFFLElBQUksQ0FBRSxDQUFDO2FBQ2xDO1NBQ0Q7S0FDRDtBQUNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcm9qZWN0LCBDYWxsRXhwcmVzc2lvbiwgQ2xhc3NEZWNsYXJhdGlvbiwgQ29uc3RydWN0b3JEZWNsYXJhdGlvbiwgRnVuY3Rpb25EZWNsYXJhdGlvbiwgTWV0aG9kRGVjbGFyYXRpb24sIE5ld0V4cHJlc3Npb24sIE5vZGUsIFNvdXJjZUZpbGUsIFN5bnRheEtpbmQgfSBmcm9tIFwidHMtbW9ycGhcIjtcbmltcG9ydCBsb2dnZXIgZnJvbSBcIi4uL2xvZ2dlci9sb2dnZXJcIjtcblxudHlwZSBOYW1lYWJsZUZ1bmN0aW9uID0gRnVuY3Rpb25EZWNsYXJhdGlvbiB8IE1ldGhvZERlY2xhcmF0aW9uO1xudHlwZSBGdW5jdGlvblRyYW5zZm9ybVRhcmdldCA9IE5hbWVhYmxlRnVuY3Rpb24gfCBDb25zdHJ1Y3RvckRlY2xhcmF0aW9uO1xuXG4vKipcbiAqIEFkZHMgdGhlIHF1ZXN0aW9uIHRva2VuIHRvIGZ1bmN0aW9uL21ldGhvZC9jb25zdHJ1Y3RvciBwYXJhbWV0ZXJzIHRoYXQgYXJlXG4gKiBkZWVtZWQgdG8gYmUgb3B0aW9uYWwgYmFzZWQgb24gdGhlIGNhbGxzIHRvIHRoYXQgZnVuY3Rpb24vbWV0aG9kL2NvbnN0cnVjdG9yXG4gKiBpbiB0aGUgY29kZWJhc2UuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHdlIGhhdmU6XG4gKlxuICogICAgIGZ1bmN0aW9uIG15Rm4oIGFyZzEsIGFyZzIsIGFyZzMgKSB7XG4gKiAgICAgICAgIC8vIC4uLlxuICogICAgIH1cbiAqXG4gKiAgICAgbXlGbiggMSwgMiwgMyApOyAgLy8gYWxsIDMgYXJncyBwcm92aWRlZFxuICogICAgIG15Rm4oIDEsIDIgKTsgICAgIC8vIDwtLSBhIGNhbGwgc2l0ZSBvbmx5IHByb3ZpZGVzIHR3byBhcmd1bWVudHNcbiAqXG4gKiBUaGVuIHRoZSByZXN1bHRpbmcgVHlwZVNjcmlwdCBmdW5jdGlvbiB3aWxsIGJlOlxuICpcbiAqICAgICBmdW5jdGlvbiBteUZuKCBhcmcxLCBhcmcyLCBhcmczPyApIHsgICAvLyA8LS0gYXJnMyBtYXJrZWQgYXMgb3B0aW9uYWxcbiAqICAgICAgICAgLy8gLi4uXG4gKiAgICAgfVxuICpcbiAqIE5vdGU6IEp1c3QgY2FsbGluZyB0aGUgbGFuZ3VhZ2Ugc2VydmljZSB0byBsb29rIHVwIHJlZmVyZW5jZXMgdGFrZXMgYSBsb3Qgb2ZcbiAqIHRpbWUuIE1pZ2h0IGhhdmUgdG8gb3B0aW1pemUgdGhpcyBzb21laG93IGluIHRoZSBmdXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRPcHRpb25hbHNUb0Z1bmN0aW9uUGFyYW1zKCB0c0FzdFByb2plY3Q6IFByb2plY3QgKTogUHJvamVjdCB7XG5cdGxvZ2dlci52ZXJib3NlKCAnQmVnaW5uaW5nIHJvdXRpbmUgdG8gbWFyayBmdW5jdGlvbiBwYXJhbWV0ZXJzIGFzIG9wdGlvbmFsIHdoZW4gY2FsbHMgZXhpc3QgdGhhdCBzdXBwbHkgZmV3ZXIgYXJncyB0aGFuIHBhcmFtZXRlcnMuLi4nICk7XG5cdGNvbnN0IHNvdXJjZUZpbGVzID0gdHNBc3RQcm9qZWN0LmdldFNvdXJjZUZpbGVzKCk7XG5cblx0bG9nZ2VyLnZlcmJvc2UoICdQYXJzaW5nIGZ1bmN0aW9uL21ldGhvZC9jb25zdHJ1Y3RvciBjYWxscyBmcm9tIGNvZGViYXNlLicgKTtcblx0Y29uc3QgY29uc3RydWN0b3JNaW5BcmdzTWFwID0gcGFyc2VDbGFzc0NvbnN0cnVjdG9yQ2FsbHMoIHNvdXJjZUZpbGVzICk7XG5cdGNvbnN0IGZ1bmN0aW9uc01pbkFyZ3NNYXAgPSBwYXJzZUZ1bmN0aW9uQW5kTWV0aG9kQ2FsbHMoIHNvdXJjZUZpbGVzICk7XG5cblx0bG9nZ2VyLnZlcmJvc2UoICdNYXJraW5nIHBhcmFtZXRlcnMgYXMgb3B0aW9uYWwnICk7XG5cdGFkZE9wdGlvbmFscyggY29uc3RydWN0b3JNaW5BcmdzTWFwICk7XG5cdGFkZE9wdGlvbmFscyggZnVuY3Rpb25zTWluQXJnc01hcCApO1xuXG5cdHJldHVybiB0c0FzdFByb2plY3Q7XG59XG5cblxuLyoqXG4gKiBGaW5kcyB0aGUgY2FsbCBzaXRlcyBvZiBlYWNoIENsYXNzRGVjbGFyYXRpb24ncyBjb25zdHJ1Y3RvciBpbiBvcmRlciB0b1xuICogZGV0ZXJtaW5lIGlmIGFueSBvZiBpdHMgcGFyYW1ldGVycyBzaG91bGQgYmUgbWFya2VkIGFzIG9wdGlvbmFsLlxuICpcbiAqIFJldHVybnMgYSBNYXAga2V5ZWQgYnkgQ2xhc3NEZWNsYXJhdGlvbiB3aGljaCBjb250YWlucyB0aGUgbWluaW11bSBudW1iZXIgb2ZcbiAqIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhhdCBjbGFzcydzIGNvbnN0cnVjdG9yLlxuICpcbiAqIEFjdHVhbGx5IG1hcmtpbmcgdGhlIHBhcmFtZXRlcnMgYXMgb3B0aW9uYWwgaXMgZG9uZSBpbiBhIHNlcGFyYXRlIHBoYXNlLlxuICovXG5mdW5jdGlvbiBwYXJzZUNsYXNzQ29uc3RydWN0b3JDYWxscyggc291cmNlRmlsZXM6IFNvdXJjZUZpbGVbXSApOiBNYXA8Q29uc3RydWN0b3JEZWNsYXJhdGlvbiwgbnVtYmVyPiB7XG5cdGxvZ2dlci52ZXJib3NlKCAnRmluZGluZyBhbGwgY2FsbHMgdG8gY2xhc3MgY29uc3RydWN0b3JzLi4uJyApO1xuXHRjb25zdCBjb25zdHJ1Y3Rvck1pbkFyZ3NNYXAgPSBuZXcgTWFwPENvbnN0cnVjdG9yRGVjbGFyYXRpb24sIG51bWJlcj4oKTtcblxuXHRzb3VyY2VGaWxlcy5mb3JFYWNoKCAoIHNvdXJjZUZpbGU6IFNvdXJjZUZpbGUgKSA9PiB7XG5cdFx0bG9nZ2VyLnZlcmJvc2UoIGAgIFByb2Nlc3NpbmcgY2xhc3NlcyBpbiBzb3VyY2UgZmlsZTogJHtzb3VyY2VGaWxlLmdldEZpbGVQYXRoKCl9YCApO1xuXHRcdGNvbnN0IGNsYXNzZXMgPSBzb3VyY2VGaWxlLmdldERlc2NlbmRhbnRzT2ZLaW5kKCBTeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb24gKTtcblxuXHRcdGNsYXNzZXMuZm9yRWFjaCggKCBjbGFzc0RlY2xhcmF0aW9uOiBDbGFzc0RlY2xhcmF0aW9uICkgPT4ge1xuXHRcdFx0Y29uc3QgY29uc3RydWN0b3JGbnMgPSBjbGFzc0RlY2xhcmF0aW9uLmdldENvbnN0cnVjdG9ycygpIHx8IFtdO1xuXHRcdFx0Y29uc3QgY29uc3RydWN0b3JGbiA9IGNvbnN0cnVjdG9yRm5zLmxlbmd0aCA+IDAgPyBjb25zdHJ1Y3RvckZuc1sgMCBdIDogdW5kZWZpbmVkOyAgLy8gb25seSBncmFiIHRoZSBmaXJzdCBzaW5jZSB3ZSdyZSBjb252ZXJ0aW5nIEphdmFTY3JpcHRcblxuXHRcdFx0Ly8gSWYgdGhlcmUgaXMgbm8gY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoaXMgY2xhc3MsIHRoZW4gbm90aGluZyB0byBkb1xuXHRcdFx0aWYoICFjb25zdHJ1Y3RvckZuICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGxvZ2dlci52ZXJib3NlKCBgICAgIExvb2tpbmcgZm9yIGNhbGxzIHRvIHRoZSBjb25zdHJ1Y3RvciBvZiBjbGFzczogJyR7Y2xhc3NEZWNsYXJhdGlvbi5nZXROYW1lKCl9J2AgKTtcblxuXHRcdFx0Y29uc3QgY29uc3RydWN0b3JGblBhcmFtcyA9IGNvbnN0cnVjdG9yRm4uZ2V0UGFyYW1ldGVycygpO1xuXHRcdFx0Y29uc3QgbnVtUGFyYW1zID0gY29uc3RydWN0b3JGblBhcmFtcy5sZW5ndGg7XG5cblx0XHRcdGNvbnN0IHJlZmVyZW5jZWROb2RlcyA9IGNsYXNzRGVjbGFyYXRpb24uZmluZFJlZmVyZW5jZXNBc05vZGVzKCk7XG5cblx0XHRcdGNvbnN0IGNhbGxzVG9Db25zdHJ1Y3RvciA9IHJlZmVyZW5jZWROb2Rlc1xuXHRcdFx0XHQubWFwKCAoIG5vZGU6IE5vZGUgKSA9PiBub2RlLmdldEZpcnN0QW5jZXN0b3JCeUtpbmQoIFN5bnRheEtpbmQuTmV3RXhwcmVzc2lvbiApIClcblx0XHRcdFx0LmZpbHRlciggKCBub2RlICk6IG5vZGUgaXMgTmV3RXhwcmVzc2lvbiA9PiAhIW5vZGUgKTtcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCBgICAgIEZvdW5kICR7Y2FsbHNUb0NvbnN0cnVjdG9yLmxlbmd0aH0gY2FsbChzKSB0byB0aGUgY29uc3RydWN0b3JgICk7XG5cblx0XHRcdGNvbnN0IG1pbk51bWJlck9mQ2FsbEFyZ3MgPSBjYWxsc1RvQ29uc3RydWN0b3Jcblx0XHRcdFx0LnJlZHVjZSggKCBtaW5DYWxsQXJnczogbnVtYmVyLCBjYWxsOiBOZXdFeHByZXNzaW9uICkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1pbiggbWluQ2FsbEFyZ3MsIGNhbGwuZ2V0QXJndW1lbnRzKCkubGVuZ3RoICk7XG5cdFx0XHRcdH0sIG51bVBhcmFtcyApO1xuXG5cdFx0XHRpZiggY2FsbHNUb0NvbnN0cnVjdG9yLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1ZyggYCAgICBDb25zdHJ1Y3RvciBjdXJyZW50bHkgZXhwZWN0cyAke251bVBhcmFtc30gcGFyYW1zLiBDYWxsKHMpIHRvIHRoZSBjb25zdHJ1Y3RvciBzdXBwbHkgYSBtaW5pbXVtIG9mICR7bWluTnVtYmVyT2ZDYWxsQXJnc30gYXJncy5gICk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0cnVjdG9yTWluQXJnc01hcC5zZXQoIGNvbnN0cnVjdG9yRm4sIG1pbk51bWJlck9mQ2FsbEFyZ3MgKTtcblx0XHR9ICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gY29uc3RydWN0b3JNaW5BcmdzTWFwO1xufVxuXG5cbi8qKlxuICogRmluZHMgdGhlIGNhbGwgc2l0ZXMgb2YgZWFjaCBGdW5jdGlvbkRlY2xhcmF0aW9uIG9yIE1ldGhvZERlY2xhcmF0aW9uIGluXG4gKiBvcmRlciB0byBkZXRlcm1pbmUgaWYgYW55IG9mIGl0cyBwYXJhbWV0ZXJzIHNob3VsZCBiZSBtYXJrZWQgYXMgb3B0aW9uYWwuXG4gKlxuICogUmV0dXJucyBhIE1hcCBrZXllZCBieSBGdW5jdGlvbkRlY2xhcmF0aW9uIG9yIE1ldGhvZERlY2xhcmF0aW9uIHdoaWNoIGNvbnRhaW5zXG4gKiB0aGUgbWluaW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHBhc3NlZCB0byB0aGF0IGZ1bmN0aW9uL21ldGhvZC5cbiAqXG4gKiBBY3R1YWxseSBtYXJraW5nIHRoZSBwYXJhbWV0ZXJzIGFzIG9wdGlvbmFsIGlzIGRvbmUgaW4gYSBzZXBhcmF0ZSBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkFuZE1ldGhvZENhbGxzKCBzb3VyY2VGaWxlczogU291cmNlRmlsZVtdICk6IE1hcDxOYW1lYWJsZUZ1bmN0aW9uLCBudW1iZXI+IHtcblx0bG9nZ2VyLnZlcmJvc2UoICdGaW5kaW5nIGFsbCBjYWxscyB0byBmdW5jdGlvbnMvbWV0aG9kcy4uLicgKTtcblx0Y29uc3QgZnVuY3Rpb25zTWluQXJnc01hcCA9IG5ldyBNYXA8TmFtZWFibGVGdW5jdGlvbiwgbnVtYmVyPigpO1xuXG5cdHNvdXJjZUZpbGVzLmZvckVhY2goICggc291cmNlRmlsZTogU291cmNlRmlsZSApID0+IHtcblx0XHRsb2dnZXIudmVyYm9zZSggYCAgUHJvY2Vzc2luZyBmdW5jdGlvbnMvbWV0aG9kcyBpbiBzb3VyY2UgZmlsZTogJHtzb3VyY2VGaWxlLmdldEZpbGVQYXRoKCl9YCApO1xuXHRcdGNvbnN0IGZucyA9IGdldEZ1bmN0aW9uc0FuZE1ldGhvZHMoIHNvdXJjZUZpbGUgKTtcblxuXHRcdGZucy5mb3JFYWNoKCAoIGZuOiBOYW1lYWJsZUZ1bmN0aW9uICkgPT4ge1xuXHRcdFx0bG9nZ2VyLnZlcmJvc2UoIGAgICAgTG9va2luZyBmb3IgY2FsbHMgdG8gdGhlIGZ1bmN0aW9uOiAnJHtmbi5nZXROYW1lKCl9J2AgKTtcblx0XHRcdGNvbnN0IGZuUGFyYW1zID0gZm4uZ2V0UGFyYW1ldGVycygpO1xuXHRcdFx0Y29uc3QgbnVtUGFyYW1zID0gZm5QYXJhbXMubGVuZ3RoO1xuXG5cdFx0XHRjb25zdCByZWZlcmVuY2VkTm9kZXMgPSBmbi5maW5kUmVmZXJlbmNlc0FzTm9kZXMoKTtcblxuXHRcdFx0Y29uc3QgY2FsbHNUb0Z1bmN0aW9uID0gcmVmZXJlbmNlZE5vZGVzXG5cdFx0XHRcdC5tYXAoICggbm9kZTogTm9kZSApID0+IG5vZGUuZ2V0Rmlyc3RBbmNlc3RvckJ5S2luZCggU3ludGF4S2luZC5DYWxsRXhwcmVzc2lvbiApIClcblx0XHRcdFx0LmZpbHRlciggKCBub2RlICk6IG5vZGUgaXMgQ2FsbEV4cHJlc3Npb24gPT4gISFub2RlICk7XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZyggYCAgICBGb3VuZCAke2NhbGxzVG9GdW5jdGlvbi5sZW5ndGh9IGNhbGwocykgdG8gdGhlIGZ1bmN0aW9uICcke2ZuLmdldE5hbWUoKX0nYCApO1xuXG5cdFx0XHRjb25zdCBtaW5OdW1iZXJPZkNhbGxBcmdzID0gY2FsbHNUb0Z1bmN0aW9uXG5cdFx0XHRcdC5yZWR1Y2UoICggbWluQ2FsbEFyZ3M6IG51bWJlciwgY2FsbDogQ2FsbEV4cHJlc3Npb24gKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWluKCBtaW5DYWxsQXJncywgY2FsbC5nZXRBcmd1bWVudHMoKS5sZW5ndGggKTtcblx0XHRcdFx0fSwgbnVtUGFyYW1zICk7XG5cblx0XHRcdGlmKCBjYWxsc1RvRnVuY3Rpb24ubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKCBgICAgIEZ1bmN0aW9uIGN1cnJlbnRseSBleHBlY3RzICR7bnVtUGFyYW1zfSBwYXJhbXMuIENhbGwocykgdG8gdGhlIGZ1bmN0aW9uL21ldGhvZCBzdXBwbHkgYSBtaW5pbXVtIG9mICR7bWluTnVtYmVyT2ZDYWxsQXJnc30gYXJncy5gICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uc01pbkFyZ3NNYXAuc2V0KCBmbiwgbWluTnVtYmVyT2ZDYWxsQXJncyApO1xuXHRcdH0gKTtcblx0fSApO1xuXG5cdHJldHVybiBmdW5jdGlvbnNNaW5BcmdzTWFwO1xufVxuXG5cbi8qKlxuICogUmV0cmlldmVzIGFsbCBGdW5jdGlvbkRlY2xhcmF0aW9ucyBhbmQgTWV0aG9kRGVjbGFyYXRpb25zIGZyb20gdGhlIGdpdmVuXG4gKiBzb3VyY2UgZmlsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RnVuY3Rpb25zQW5kTWV0aG9kcyhcblx0c291cmNlRmlsZTogU291cmNlRmlsZVxuKTogTmFtZWFibGVGdW5jdGlvbltdIHtcblx0cmV0dXJuICggW10gYXMgTmFtZWFibGVGdW5jdGlvbltdICkuY29uY2F0KFxuXHRcdHNvdXJjZUZpbGUuZ2V0RGVzY2VuZGFudHNPZktpbmQoIFN5bnRheEtpbmQuRnVuY3Rpb25EZWNsYXJhdGlvbiApLFxuXHRcdHNvdXJjZUZpbGUuZ2V0RGVzY2VuZGFudHNPZktpbmQoIFN5bnRheEtpbmQuTWV0aG9kRGVjbGFyYXRpb24gKVxuXHQpO1xufVxuXG5cblxuLyoqXG4gKiBNYXJrcyBwYXJhbWV0ZXJzIG9mIGNsYXNzIGNvbnN0cnVjdG9ycyAvIG1ldGhvZHMgLyBmdW5jdGlvbnMgYXMgb3B0aW9uYWxcbiAqIGJhc2VkIG9uIHRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgcGFzc2VkIGluIGF0IGl0cyBjYWxsIHNpdGVzLlxuICpcbiAqIEV4OlxuICpcbiAqICAgICBjbGFzcyBTb21lQ2xhc3Mge1xuICogICAgICAgICBjb25zdHJ1Y3RvciggYXJnMSwgYXJnMiApIHt9XG4gKiAgICAgfVxuICogICAgIG5ldyBTb21lQ2xhc3MoIDEgKTsgIC8vIG5vIGFyZzJcbiAqXG4gKiAgICAgZnVuY3Rpb24gbXlGbiggYXJnMSwgYXJnMiApIHt9XG4gKiAgICAgbXlGbigpOyAgLy8gbm8gYXJnc1xuICpcbiAqXG4gKiBPdXRwdXQgY2xhc3MgYW5kIGZ1bmN0aW9uOlxuICpcbiAqICAgICBjbGFzcyBTb21lQ2xhc3Mge1xuICogICAgICAgICBjb25zdHJ1Y3RvciggYXJnMSwgYXJnMj8gKSB7fSAgLy8gPC0tIGFyZzIgbWFya2VkIGFzIG9wdGlvbmFsXG4gKiAgICAgfVxuICpcbiAqICAgICBmdW5jdGlvbiBteUZuKCBhcmcxPywgYXJnMj8gKSB7fSAgIC8vIDwtLSBhcmcxIGFuZCBhcmcyIG1hcmtlZCBhcyBvcHRpb25hbFxuICovXG5mdW5jdGlvbiBhZGRPcHRpb25hbHMoIG1pbkFyZ3NNYXA6IE1hcDxGdW5jdGlvblRyYW5zZm9ybVRhcmdldCwgbnVtYmVyPiApIHtcblx0Y29uc3QgZm5zID0gbWluQXJnc01hcC5rZXlzKCk7XG5cblx0Zm9yKCBjb25zdCBmbiBvZiBmbnMgKSB7XG5cdFx0Y29uc3QgZm5QYXJhbXMgPSBmbi5nZXRQYXJhbWV0ZXJzKCk7XG5cblx0XHRjb25zdCBudW1QYXJhbXMgPSBmblBhcmFtcy5sZW5ndGg7XG5cdFx0Y29uc3QgbWluTnVtYmVyT2ZDYWxsQXJncyA9IG1pbkFyZ3NNYXAuZ2V0KCBmbiApITtcblxuXHRcdC8vIE1hcmsgYWxsIHBhcmFtZXRlcnMgZ3JlYXRlciB0aGFuIHRoZSBtaW5OdW1iZXJPZkNhbGxBcmdzIGFzXG5cdFx0Ly8gb3B0aW9uYWwgKGlmIGl0J3Mgbm90IGEgcmVzdCBwYXJhbWV0ZXIgb3IgYWxyZWFkeSBoYXMgYSBkZWZhdWx0IHZhbHVlKVxuXHRcdGZvciggbGV0IGkgPSBtaW5OdW1iZXJPZkNhbGxBcmdzOyBpIDwgbnVtUGFyYW1zOyBpKysgKSB7XG5cdFx0XHRjb25zdCBwYXJhbSA9IGZuUGFyYW1zWyBpIF07XG5cblx0XHRcdGlmKCAhcGFyYW0uaXNSZXN0UGFyYW1ldGVyKCkgJiYgIXBhcmFtLmhhc0luaXRpYWxpemVyKCkgKSB7XG5cdFx0XHRcdHBhcmFtLnNldEhhc1F1ZXN0aW9uVG9rZW4oIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0iXX0=