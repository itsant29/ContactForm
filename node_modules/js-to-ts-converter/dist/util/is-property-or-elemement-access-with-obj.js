"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const is_property_access_with_obj_1 = require("./is-property-access-with-obj");
const is_element_access_with_obj_1 = require("./is-element-access-with-obj");
/**
 * Determines if the given `node` is a PropertyAccessExpression or
 * ElementAccessExpression whose object is `obj`.
 *
 * Example, in the following expression:
 *
 *     obj.a
 *
 * This function will return true if called as:
 *
 *     isPropertyOrElemementAccessWithObj( expr, 'obj' );
 */
function isPropertyOrElemementAccessWithObj(node, objIdentifier) {
    return is_property_access_with_obj_1.isPropertyAccessWithObj(node, objIdentifier)
        || is_element_access_with_obj_1.isElementAccessWithObj(node, objIdentifier);
}
exports.isPropertyOrElemementAccessWithObj = isPropertyOrElemementAccessWithObj;
/**
 * Function intended to be used with Array.prototype.filter() to return any
 * PropertyAccessExpression or ElementAccessExpression that uses the object
 * `obj`.
 *
 * For example, in this source code:
 *
 *     const obj = { a: 1, b: 2 };
 *     obj.a = 3;
 *     obj['b'] = 4;
 *
 *     const obj2 = { a: 3, b: 4 };
 *     obj2.a = 5;
 *     obj2['b'] = 6;
 *
 * We can use the following to find the two 'obj2' property accesses:
 *
 *     const propOrElementAccesses = sourceFile
 *         .getDescendantsOfKind( SyntaxKind.PropertyAccessExpression )
 *         .concat( sourceFile
 *             .getDescendantsOfKind( SyntaxKind.ElementAccessExpression )
 *         );
 *
 *     const obj2PropOrElemAccesses = propOrElementAccesses
 *         .filter( propertyOrElementAccessWithObjFilter( 'obj2' ) );
 */
function propertyOrElementAccessWithObjFilter(objIdentifier) {
    return (node) => {
        return isPropertyOrElemementAccessWithObj(node, objIdentifier);
    };
}
exports.propertyOrElementAccessWithObjFilter = propertyOrElementAccessWithObjFilter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXMtcHJvcGVydHktb3ItZWxlbWVtZW50LWFjY2Vzcy13aXRoLW9iai5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2lzLXByb3BlcnR5LW9yLWVsZW1lbWVudC1hY2Nlc3Mtd2l0aC1vYmoudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFDQSwrRUFBd0U7QUFDeEUsNkVBQXNFO0FBRXRFOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsNENBQ0MsSUFBVSxFQUNWLGFBQXFCO0lBRXJCLE9BQU8scURBQXVCLENBQUUsSUFBSSxFQUFFLGFBQWEsQ0FBRTtXQUNqRCxtREFBc0IsQ0FBRSxJQUFJLEVBQUUsYUFBYSxDQUFFLENBQUM7QUFDbkQsQ0FBQztBQU5ELGdGQU1DO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F5Qkc7QUFDSCw4Q0FBc0QsYUFBcUI7SUFDMUUsT0FBTyxDQUFFLElBQVUsRUFBK0QsRUFBRTtRQUNuRixPQUFPLGtDQUFrQyxDQUFFLElBQUksRUFBRSxhQUFhLENBQUUsQ0FBQztJQUNsRSxDQUFDLENBQUM7QUFDSCxDQUFDO0FBSkQsb0ZBSUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50QWNjZXNzRXhwcmVzc2lvbiwgSWRlbnRpZmllciwgTm9kZSwgUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uLCBUeXBlR3VhcmRzIH0gZnJvbSBcInRzLW1vcnBoXCI7XG5pbXBvcnQgeyBpc1Byb3BlcnR5QWNjZXNzV2l0aE9iaiB9IGZyb20gXCIuL2lzLXByb3BlcnR5LWFjY2Vzcy13aXRoLW9ialwiO1xuaW1wb3J0IHsgaXNFbGVtZW50QWNjZXNzV2l0aE9iaiB9IGZyb20gXCIuL2lzLWVsZW1lbnQtYWNjZXNzLXdpdGgtb2JqXCI7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGlzIGEgUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uIG9yXG4gKiBFbGVtZW50QWNjZXNzRXhwcmVzc2lvbiB3aG9zZSBvYmplY3QgaXMgYG9iamAuXG4gKlxuICogRXhhbXBsZSwgaW4gdGhlIGZvbGxvd2luZyBleHByZXNzaW9uOlxuICpcbiAqICAgICBvYmouYVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdHJ1ZSBpZiBjYWxsZWQgYXM6XG4gKlxuICogICAgIGlzUHJvcGVydHlPckVsZW1lbWVudEFjY2Vzc1dpdGhPYmooIGV4cHIsICdvYmonICk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb3BlcnR5T3JFbGVtZW1lbnRBY2Nlc3NXaXRoT2JqKFxuXHRub2RlOiBOb2RlLFxuXHRvYmpJZGVudGlmaWVyOiBzdHJpbmdcbik6IG5vZGUgaXMgUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uIHwgRWxlbWVudEFjY2Vzc0V4cHJlc3Npb24ge1xuXHRyZXR1cm4gaXNQcm9wZXJ0eUFjY2Vzc1dpdGhPYmooIG5vZGUsIG9iaklkZW50aWZpZXIgKVxuXHRcdHx8IGlzRWxlbWVudEFjY2Vzc1dpdGhPYmooIG5vZGUsIG9iaklkZW50aWZpZXIgKTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGggQXJyYXkucHJvdG90eXBlLmZpbHRlcigpIHRvIHJldHVybiBhbnlcbiAqIFByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiBvciBFbGVtZW50QWNjZXNzRXhwcmVzc2lvbiB0aGF0IHVzZXMgdGhlIG9iamVjdFxuICogYG9iamAuXG4gKlxuICogRm9yIGV4YW1wbGUsIGluIHRoaXMgc291cmNlIGNvZGU6XG4gKlxuICogICAgIGNvbnN0IG9iaiA9IHsgYTogMSwgYjogMiB9O1xuICogICAgIG9iai5hID0gMztcbiAqICAgICBvYmpbJ2InXSA9IDQ7XG4gKlxuICogICAgIGNvbnN0IG9iajIgPSB7IGE6IDMsIGI6IDQgfTtcbiAqICAgICBvYmoyLmEgPSA1O1xuICogICAgIG9iajJbJ2InXSA9IDY7XG4gKlxuICogV2UgY2FuIHVzZSB0aGUgZm9sbG93aW5nIHRvIGZpbmQgdGhlIHR3byAnb2JqMicgcHJvcGVydHkgYWNjZXNzZXM6XG4gKlxuICogICAgIGNvbnN0IHByb3BPckVsZW1lbnRBY2Nlc3NlcyA9IHNvdXJjZUZpbGVcbiAqICAgICAgICAgLmdldERlc2NlbmRhbnRzT2ZLaW5kKCBTeW50YXhLaW5kLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiApXG4gKiAgICAgICAgIC5jb25jYXQoIHNvdXJjZUZpbGVcbiAqICAgICAgICAgICAgIC5nZXREZXNjZW5kYW50c09mS2luZCggU3ludGF4S2luZC5FbGVtZW50QWNjZXNzRXhwcmVzc2lvbiApXG4gKiAgICAgICAgICk7XG4gKlxuICogICAgIGNvbnN0IG9iajJQcm9wT3JFbGVtQWNjZXNzZXMgPSBwcm9wT3JFbGVtZW50QWNjZXNzZXNcbiAqICAgICAgICAgLmZpbHRlciggcHJvcGVydHlPckVsZW1lbnRBY2Nlc3NXaXRoT2JqRmlsdGVyKCAnb2JqMicgKSApO1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcGVydHlPckVsZW1lbnRBY2Nlc3NXaXRoT2JqRmlsdGVyKCBvYmpJZGVudGlmaWVyOiBzdHJpbmcgKTogKCBub2RlOiBOb2RlICkgPT4gbm9kZSBpcyBQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24gfCBFbGVtZW50QWNjZXNzRXhwcmVzc2lvbiB7XG5cdHJldHVybiAoIG5vZGU6IE5vZGUgKTogbm9kZSBpcyBQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24gfCBFbGVtZW50QWNjZXNzRXhwcmVzc2lvbiA9PiB7XG5cdFx0cmV0dXJuIGlzUHJvcGVydHlPckVsZW1lbWVudEFjY2Vzc1dpdGhPYmooIG5vZGUsIG9iaklkZW50aWZpZXIgKTtcblx0fTtcbn0iXX0=