"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts_morph_1 = require("ts-morph");
/**
 * Determines if the given `node` is a ElementAccessExpression whose object is
 * `obj`.
 *
 * Example, in the following expression:
 *
 *     obj['a']
 *
 * This function will return true if called as:
 *
 *     isElementAccessWithObj( expr, 'obj' );
 */
function isElementAccessWithObj(node, objIdentifier) {
    if (!ts_morph_1.TypeGuards.isElementAccessExpression(node)) {
        return false;
    }
    const expr = node.getExpression();
    if (objIdentifier === 'this') {
        return ts_morph_1.TypeGuards.isThisExpression(expr);
    }
    else if (ts_morph_1.TypeGuards.isIdentifier(expr)) {
        const identifier = expr;
        return identifier.getText() === objIdentifier;
    }
    else {
        return false;
    }
}
exports.isElementAccessWithObj = isElementAccessWithObj;
/**
 * Function intended to be used with Array.prototype.filter() to return any
 * ElementAccessExpression that uses the object `obj`.
 *
 * For example, in this source code:
 *
 *     const obj = { a: 1, b: 2 };
 *     obj['a'] = 3;
 *
 *     const obj2 = { a: 3, b: 4 };
 *     obj2['b'] = 5;
 *
 * We can use the following to find the 'obj2' element access:
 *
 *     const propAccesses = sourceFile
 *         .getDescendantsOfKind( SyntaxKind.ElementAccessExpression );
 *
 *     const obj2PropAccesses = propAccesses
 *         .filter( elementAccessWithObjFilter( 'obj2' ) );
 */
function elementAccessWithObjFilter(objIdentifier) {
    return (node) => {
        return isElementAccessWithObj(node, objIdentifier);
    };
}
exports.elementAccessWithObjFilter = elementAccessWithObjFilter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXMtZWxlbWVudC1hY2Nlc3Mtd2l0aC1vYmouanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbC9pcy1lbGVtZW50LWFjY2Vzcy13aXRoLW9iai50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHVDQUFpRjtBQUVqRjs7Ozs7Ozs7Ozs7R0FXRztBQUNILGdDQUNDLElBQVUsRUFDVixhQUFxQjtJQUVyQixJQUFJLENBQUMscUJBQVUsQ0FBQyx5QkFBeUIsQ0FBRSxJQUFJLENBQUUsRUFBRztRQUNuRCxPQUFPLEtBQUssQ0FBQztLQUNiO0lBRUQsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBRWxDLElBQUksYUFBYSxLQUFLLE1BQU0sRUFBRztRQUM5QixPQUFPLHFCQUFVLENBQUMsZ0JBQWdCLENBQUUsSUFBSSxDQUFFLENBQUM7S0FFM0M7U0FBTSxJQUFJLHFCQUFVLENBQUMsWUFBWSxDQUFFLElBQUksQ0FBRSxFQUFHO1FBQzVDLE1BQU0sVUFBVSxHQUFHLElBQWtCLENBQUM7UUFFdEMsT0FBTyxVQUFVLENBQUMsT0FBTyxFQUFFLEtBQUssYUFBYSxDQUFDO0tBRTlDO1NBQU07UUFDTixPQUFPLEtBQUssQ0FBQztLQUNiO0FBQ0YsQ0FBQztBQXJCRCx3REFxQkM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1CRztBQUNILG9DQUE0QyxhQUFxQjtJQUNoRSxPQUFPLENBQUUsSUFBVSxFQUFvQyxFQUFFO1FBQ3hELE9BQU8sc0JBQXNCLENBQUUsSUFBSSxFQUFFLGFBQWEsQ0FBRSxDQUFDO0lBQ3RELENBQUMsQ0FBQztBQUNILENBQUM7QUFKRCxnRUFJQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRBY2Nlc3NFeHByZXNzaW9uLCBJZGVudGlmaWVyLCBOb2RlLCBUeXBlR3VhcmRzIH0gZnJvbSBcInRzLW1vcnBoXCI7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGlzIGEgRWxlbWVudEFjY2Vzc0V4cHJlc3Npb24gd2hvc2Ugb2JqZWN0IGlzXG4gKiBgb2JqYC5cbiAqXG4gKiBFeGFtcGxlLCBpbiB0aGUgZm9sbG93aW5nIGV4cHJlc3Npb246XG4gKlxuICogICAgIG9ialsnYSddXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0cnVlIGlmIGNhbGxlZCBhczpcbiAqXG4gKiAgICAgaXNFbGVtZW50QWNjZXNzV2l0aE9iaiggZXhwciwgJ29iaicgKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudEFjY2Vzc1dpdGhPYmooXG5cdG5vZGU6IE5vZGUsXG5cdG9iaklkZW50aWZpZXI6IHN0cmluZ1xuKTogbm9kZSBpcyBFbGVtZW50QWNjZXNzRXhwcmVzc2lvbiB7XG5cdGlmKCAhVHlwZUd1YXJkcy5pc0VsZW1lbnRBY2Nlc3NFeHByZXNzaW9uKCBub2RlICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Y29uc3QgZXhwciA9IG5vZGUuZ2V0RXhwcmVzc2lvbigpO1xuXG5cdGlmKCBvYmpJZGVudGlmaWVyID09PSAndGhpcycgKSB7XG5cdFx0cmV0dXJuIFR5cGVHdWFyZHMuaXNUaGlzRXhwcmVzc2lvbiggZXhwciApO1xuXG5cdH0gZWxzZSBpZiggVHlwZUd1YXJkcy5pc0lkZW50aWZpZXIoIGV4cHIgKSApIHtcblx0XHRjb25zdCBpZGVudGlmaWVyID0gZXhwciBhcyBJZGVudGlmaWVyO1xuXG5cdFx0cmV0dXJuIGlkZW50aWZpZXIuZ2V0VGV4dCgpID09PSBvYmpJZGVudGlmaWVyO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbi8qKlxuICogRnVuY3Rpb24gaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoKSB0byByZXR1cm4gYW55XG4gKiBFbGVtZW50QWNjZXNzRXhwcmVzc2lvbiB0aGF0IHVzZXMgdGhlIG9iamVjdCBgb2JqYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaW4gdGhpcyBzb3VyY2UgY29kZTpcbiAqXG4gKiAgICAgY29uc3Qgb2JqID0geyBhOiAxLCBiOiAyIH07XG4gKiAgICAgb2JqWydhJ10gPSAzO1xuICpcbiAqICAgICBjb25zdCBvYmoyID0geyBhOiAzLCBiOiA0IH07XG4gKiAgICAgb2JqMlsnYiddID0gNTtcbiAqXG4gKiBXZSBjYW4gdXNlIHRoZSBmb2xsb3dpbmcgdG8gZmluZCB0aGUgJ29iajInIGVsZW1lbnQgYWNjZXNzOlxuICpcbiAqICAgICBjb25zdCBwcm9wQWNjZXNzZXMgPSBzb3VyY2VGaWxlXG4gKiAgICAgICAgIC5nZXREZXNjZW5kYW50c09mS2luZCggU3ludGF4S2luZC5FbGVtZW50QWNjZXNzRXhwcmVzc2lvbiApO1xuICpcbiAqICAgICBjb25zdCBvYmoyUHJvcEFjY2Vzc2VzID0gcHJvcEFjY2Vzc2VzXG4gKiAgICAgICAgIC5maWx0ZXIoIGVsZW1lbnRBY2Nlc3NXaXRoT2JqRmlsdGVyKCAnb2JqMicgKSApO1xuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudEFjY2Vzc1dpdGhPYmpGaWx0ZXIoIG9iaklkZW50aWZpZXI6IHN0cmluZyApOiAoIG5vZGU6IE5vZGUgKSA9PiBub2RlIGlzIEVsZW1lbnRBY2Nlc3NFeHByZXNzaW9uIHtcblx0cmV0dXJuICggbm9kZTogTm9kZSApOiBub2RlIGlzIEVsZW1lbnRBY2Nlc3NFeHByZXNzaW9uID0+IHtcblx0XHRyZXR1cm4gaXNFbGVtZW50QWNjZXNzV2l0aE9iaiggbm9kZSwgb2JqSWRlbnRpZmllciApO1xuXHR9O1xufSJdfQ==