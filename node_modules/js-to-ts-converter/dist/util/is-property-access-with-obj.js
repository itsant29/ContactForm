"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts_morph_1 = require("ts-morph");
/**
 * Determines if the given `node` is a PropertyAccessExpression or
 * ElementAccessExpression whose object is `obj`.
 *
 * Example, in the following expression:
 *
 *     obj.a
 *
 * This function will return true if called as:
 *
 *     isPropertyOrElemementAccessWithObj( expr, 'obj' );
 */
function isPropertyAccessWithObj(node, objIdentifier) {
    if (!ts_morph_1.TypeGuards.isPropertyAccessExpression(node)) {
        return false;
    }
    const expr = node.getExpression();
    if (objIdentifier === 'this') {
        return ts_morph_1.TypeGuards.isThisExpression(expr);
    }
    else if (ts_morph_1.TypeGuards.isIdentifier(expr)) {
        const identifier = expr;
        return identifier.getText() === objIdentifier;
    }
    else {
        return false;
    }
}
exports.isPropertyAccessWithObj = isPropertyAccessWithObj;
/**
 * Function intended to be used with Array.prototype.filter() to return any
 * PropertyAccessExpression that uses the object `obj`.
 *
 * For example, in this source code:
 *
 *     const obj = { a: 1, b: 2 };
 *     obj.a = 3;
 *
 *     const obj2 = { a: 3, b: 4 };
 *     obj2.b = 5;
 *
 * We can use the following to find the 'obj2' property access:
 *
 *     const propAccesses = sourceFile
 *         .getDescendantsOfKind( SyntaxKind.PropertyAccessExpression );
 *
 *     const obj2PropAccesses = propAccesses
 *         .filter( propAccessWithObjFilter( 'obj2' ) );
 */
function propertyAccessWithObjFilter(objIdentifier) {
    return (node) => {
        return isPropertyAccessWithObj(node, objIdentifier);
    };
}
exports.propertyAccessWithObjFilter = propertyAccessWithObjFilter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXMtcHJvcGVydHktYWNjZXNzLXdpdGgtb2JqLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWwvaXMtcHJvcGVydHktYWNjZXNzLXdpdGgtb2JqLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsdUNBQWtGO0FBRWxGOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsaUNBQ0MsSUFBVSxFQUNWLGFBQXFCO0lBRXJCLElBQUksQ0FBQyxxQkFBVSxDQUFDLDBCQUEwQixDQUFFLElBQUksQ0FBRSxFQUFHO1FBQ3BELE9BQU8sS0FBSyxDQUFDO0tBQ2I7SUFFRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFFbEMsSUFBSSxhQUFhLEtBQUssTUFBTSxFQUFHO1FBQzlCLE9BQU8scUJBQVUsQ0FBQyxnQkFBZ0IsQ0FBRSxJQUFJLENBQUUsQ0FBQztLQUUzQztTQUFNLElBQUkscUJBQVUsQ0FBQyxZQUFZLENBQUUsSUFBSSxDQUFFLEVBQUc7UUFDNUMsTUFBTSxVQUFVLEdBQUcsSUFBa0IsQ0FBQztRQUV0QyxPQUFPLFVBQVUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxhQUFhLENBQUM7S0FFOUM7U0FBTTtRQUNOLE9BQU8sS0FBSyxDQUFDO0tBQ2I7QUFDRixDQUFDO0FBckJELDBEQXFCQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUJHO0FBQ0gscUNBQTZDLGFBQXFCO0lBQ2pFLE9BQU8sQ0FBRSxJQUFVLEVBQXFDLEVBQUU7UUFDekQsT0FBTyx1QkFBdUIsQ0FBRSxJQUFJLEVBQUUsYUFBYSxDQUFFLENBQUM7SUFDdkQsQ0FBQyxDQUFDO0FBQ0gsQ0FBQztBQUpELGtFQUlDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSWRlbnRpZmllciwgTm9kZSwgUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uLCBUeXBlR3VhcmRzIH0gZnJvbSBcInRzLW1vcnBoXCI7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGlzIGEgUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uIG9yXG4gKiBFbGVtZW50QWNjZXNzRXhwcmVzc2lvbiB3aG9zZSBvYmplY3QgaXMgYG9iamAuXG4gKlxuICogRXhhbXBsZSwgaW4gdGhlIGZvbGxvd2luZyBleHByZXNzaW9uOlxuICpcbiAqICAgICBvYmouYVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdHJ1ZSBpZiBjYWxsZWQgYXM6XG4gKlxuICogICAgIGlzUHJvcGVydHlPckVsZW1lbWVudEFjY2Vzc1dpdGhPYmooIGV4cHIsICdvYmonICk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb3BlcnR5QWNjZXNzV2l0aE9iaihcblx0bm9kZTogTm9kZSxcblx0b2JqSWRlbnRpZmllcjogc3RyaW5nXG4pOiBub2RlIGlzIFByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiB7XG5cdGlmKCAhVHlwZUd1YXJkcy5pc1Byb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiggbm9kZSApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGNvbnN0IGV4cHIgPSBub2RlLmdldEV4cHJlc3Npb24oKTtcblxuXHRpZiggb2JqSWRlbnRpZmllciA9PT0gJ3RoaXMnICkge1xuXHRcdHJldHVybiBUeXBlR3VhcmRzLmlzVGhpc0V4cHJlc3Npb24oIGV4cHIgKTtcblxuXHR9IGVsc2UgaWYoIFR5cGVHdWFyZHMuaXNJZGVudGlmaWVyKCBleHByICkgKSB7XG5cdFx0Y29uc3QgaWRlbnRpZmllciA9IGV4cHIgYXMgSWRlbnRpZmllcjtcblxuXHRcdHJldHVybiBpZGVudGlmaWVyLmdldFRleHQoKSA9PT0gb2JqSWRlbnRpZmllcjtcblxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aCBBcnJheS5wcm90b3R5cGUuZmlsdGVyKCkgdG8gcmV0dXJuIGFueVxuICogUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uIHRoYXQgdXNlcyB0aGUgb2JqZWN0IGBvYmpgLlxuICpcbiAqIEZvciBleGFtcGxlLCBpbiB0aGlzIHNvdXJjZSBjb2RlOlxuICpcbiAqICAgICBjb25zdCBvYmogPSB7IGE6IDEsIGI6IDIgfTtcbiAqICAgICBvYmouYSA9IDM7XG4gKlxuICogICAgIGNvbnN0IG9iajIgPSB7IGE6IDMsIGI6IDQgfTtcbiAqICAgICBvYmoyLmIgPSA1O1xuICpcbiAqIFdlIGNhbiB1c2UgdGhlIGZvbGxvd2luZyB0byBmaW5kIHRoZSAnb2JqMicgcHJvcGVydHkgYWNjZXNzOlxuICpcbiAqICAgICBjb25zdCBwcm9wQWNjZXNzZXMgPSBzb3VyY2VGaWxlXG4gKiAgICAgICAgIC5nZXREZXNjZW5kYW50c09mS2luZCggU3ludGF4S2luZC5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24gKTtcbiAqXG4gKiAgICAgY29uc3Qgb2JqMlByb3BBY2Nlc3NlcyA9IHByb3BBY2Nlc3Nlc1xuICogICAgICAgICAuZmlsdGVyKCBwcm9wQWNjZXNzV2l0aE9iakZpbHRlciggJ29iajInICkgKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BlcnR5QWNjZXNzV2l0aE9iakZpbHRlciggb2JqSWRlbnRpZmllcjogc3RyaW5nICk6ICggbm9kZTogTm9kZSApID0+IG5vZGUgaXMgUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uIHtcblx0cmV0dXJuICggbm9kZTogTm9kZSApOiBub2RlIGlzIFByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiA9PiB7XG5cdFx0cmV0dXJuIGlzUHJvcGVydHlBY2Nlc3NXaXRoT2JqKCBub2RlLCBvYmpJZGVudGlmaWVyICk7XG5cdH07XG59Il19